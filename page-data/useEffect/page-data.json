{"componentChunkName":"component---src-templates-blog-post-js","path":"/useEffect/","result":{"data":{"site":{"siteMetadata":{"title":"Overblog","author":"zit"}},"markdownRemark":{"id":"85499da1-16a8-5080-ac94-7f4f4740c61e","html":"<h2 id=\"effect-的执行时机\"><a href=\"#effect-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>effect 的执行时机</h2>\n<p>在浏览器完成 layout 和 paint 之后，延迟执行。这样设计不会延迟 UI 的展示，更快的展示 UI。\n这点和类组件的 componentDidMount 不同，它会在浏览器绘制前执行。Hooks刚出现时，有人使用在 useEffect 中打日志的方式<a href=\"https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">测试性能</a>，会发现比 componentDidMount 执行的慢，原因就在于此。</p>\n<blockquote>\n<p>？？？：react 是怎么知道浏览器布局和绘制完成了呢，定时查询？所以会有<strong>延迟</strong>执行？</p>\n</blockquote>\n<h2 id=\"在任意一次渲染中，props-和-state-是始终保持不变的\"><a href=\"#%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E4%B8%AD%EF%BC%8Cprops-%E5%92%8C-state-%E6%98%AF%E5%A7%8B%E7%BB%88%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98%E7%9A%84\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在任意一次渲染中，props 和 state 是始终保持不变的</h2>\n<p>也就是说在不同渲染中的 props 和 state 是相互独立的，使用到它们的任何值也是独立的（包括事件处理函数）。它们都属于一次特定的渲染，即使是事件处理函数中的异步函数，其中使用的值也是当次渲染的值。不会因为延迟使用最新的状态值。\n来用一个实际的情况佐证一下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function-variable function\">onBtnClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'count '</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>onBtnClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">alert</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>首先连续点击按钮一 3 下，然后点击按钮二 1 下，再点击按钮一 2 下。你猜最后弹窗的 count 值是多少？</p>\n<p>如果你的答案是 5，那就错了，一起来看一下。\n连续点击第一个按钮 3 下时，count 变为了 3，此时调用的 onBtnClick 获取到的 count 是 3。当再次点击第一个按钮，整个 Counter 函数会重新执行，onBtnClick 也会重新定义，完全不会影响到我们之前调用的 onBtnClick 和其中引用的 count。所以 alert 的值是 3。</p>\n<p>每当状态更新时，整个函数都会重新执行，其中的变量、函数和之前定义的都是相互独立的，类似不同的帧。值得说明的是，dom 中使用的 count，非常单纯的就是每次重新执行后的一个常量的值，完全没有数据绑定、监听、代理之类的“黑科技”。</p>\n<p>而 effect 拿到的总是定义它的那次渲染中的 props 和 state</p>\n<blockquote>\n<p><a href=\"https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">函数式组件与类组件有何不同？</a></p>\n</blockquote>\n<h2 id=\"每次渲染都有它自己的-effects\"><a href=\"#%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84-effects\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>每次渲染都有它自己的 Effects</h2>\n<p>和组件中其它的事件处理函数一样，每次渲染都会产生属于那次渲染的 effect 函数。其中的变量也是那次渲染中的值。\n如果想在 effect 的回调函数中使用最新的值，而不是捕获的当前渲染的值，可以使用 refs。值得注意的是，如果想要在过去的渲染中定义的函数里，读取“未来”的 props 和 state，这种方式有打破默认范式的意味，可能会导致代码的脆弱性，如果有其它方式代替逻辑，最好使用其它方式。</p>\n<h2 id=\"effect-中的清理\"><a href=\"#effect-%E4%B8%AD%E7%9A%84%E6%B8%85%E7%90%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>effect 中的清理</h2>\n<p>effect 执行是在浏览器绘制之后，effect 的清除同样被延迟了。\n上一个组件中 effect 的清除函数，会在下一个组件绘制到浏览器之后，执行 useEffect 之前执行。也就是说上一个组件的清除和下一个组件的 effect 执行时机是一致的，只是前者更早。\n上一个组件和下一个组件可以是两个不同的函数组件，也可以是同一个函数组件的两次渲染。假如是同一个组件，上次渲染时产生的清除函数会在下一次渲染的绘制之后，effect 之前执行。</p>\n<p>看一下下面的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    ChatAPI<span class=\"token punctuation\">.</span><span class=\"token function\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      ChatAPI<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>props.id 从 10 变为 20 时，会发生什么呢？</p>\n<ul>\n<li>react 会优先渲染 id 为 20 时的 UI</li>\n<li>浏览器绘制 UI，用户看到 id 为 20 时的 UI</li>\n<li>清除 id 为 10 时的订阅</li>\n<li>执行 id 为 20 时的 effect\n可以看到，hooks 中 UI 的优先级更高，更注重用户体验，这也是 hooks 的“心智模型”之一。</li>\n</ul>\n<p>那么，清除函数为什么还能拿到 id 为 10 的 props 呢？\n答案就在上面，<strong>effect 拿到的总是定义它的那次渲染中的 props 和 state</strong>。一帧一帧的函数…有那么一丝感觉了吧～</p>\n<h2 id=\"同步，而非生命周期\"><a href=\"#%E5%90%8C%E6%AD%A5%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>同步，而非生命周期</h2>\n<p>从上面可以看到，Hooks 讲究的是初始渲染和后续更新的同步，而不是生命周期的复杂概念。\nreact 的每一次渲染所执行的函数、变量基本是一致的，这减少了程序的“熵”，不会让程序随着状态越来越多、更新越来越多，堆积越来越多的变化组合，导致定位 bug 很艰难。Hooks 的优势就在于每一次更新相当于重新开始，没有累积变化，程序看起来就会清晰很多。\n同步是指，React 根据当前的 props 和 state 同步修改到 Dom。没有像类组件的 “mount” 和 “update” 那样的生命周期。effect 也是类似的“心智模型”，在浏览器渲染之后，根据当前的状态，同步做 React tree 之外的修改。</p>\n<h2 id=\"依赖\"><a href=\"#%E4%BE%9D%E8%B5%96\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>依赖</h2>\n<p>effect 的依赖可以条件式的避免渲染，只在变化的时候执行。\n有时候可以通过某种方式省略依赖</p>\n<ul>\n<li>函数式更新</li>\n<li>useReducer\n使用 useCallback 常量化函数依赖</li>\n</ul>\n<p>[] 依赖比较接近类组件的 componentDidMount 和 componentWillUnmount，在这里可以执行一次第一次渲染和卸载时的逻辑。\n但是如果有些依赖尝试了以上方式后仍不可避免，那么只能在 effect 中使用条件判断的方式去执行某些逻辑，尽管这种方式可能打断了函数式组件同步执行的模型，但是好像没有什么更好的办法。</p>","timeToRead":5,"frontmatter":{"title":"useEffect 的全部","date":"July 27, 2021","spoiler":"一文搞懂 useEffect","cta":"react"},"fields":{"slug":"/useEffect/","langKey":"en"}}},"pageContext":{"slug":"/useEffect/","previous":{"fields":{"slug":"/useSate/","langKey":"en","directoryName":"useSate"},"frontmatter":{"title":"useState 的全部"}},"next":null,"translations":[],"translatedLinks":[]}},"staticQueryHashes":["708209134"]}