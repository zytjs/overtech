{"componentChunkName":"component---src-templates-blog-post-js","path":"/useContext/","result":{"data":{"site":{"siteMetadata":{"title":"Overblog","author":"zit"}},"markdownRemark":{"id":"406c80db-64a5-514c-a01a-dba2eec069b5","html":"<p>Context 提供了一个不用向每层组件手动添加 props，就能在组件树之间进行数据传递的方法。</p>\n<p>它要解决的问题是，当孙子组件需要使用爷爷组件的变量时，在父组件上进行了实际上无用的传递。React 数据一般通过 props 由父到子传递，context 提供了一种在组件间共享数据的方式，不用我们显示的层层传递数据。</p>\n<h2 id=\"使用-context-之前的考虑\"><a href=\"#%E4%BD%BF%E7%94%A8-context-%E4%B9%8B%E5%89%8D%E7%9A%84%E8%80%83%E8%99%91\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用 Context 之前的考虑</h2>\n<p><a href=\"https://zh-hans.reactjs.org/docs/context.html#before-you-use-context\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方文档说到</a>，context 会使组件的复用性变差，所以建议谨慎使用。但是如果我们在纯业务组件中并不会考虑复用性，这时候使用就没有任何问题。</p>\n<p>考虑到 context 解决的问题，有时候可以使用组件组合。这种方式是要把需要使用数据的组件提升到高层次组件，然后将组件本身层层传递下去。但是将底层逻辑提升，首先会污染高层组件，使它更复杂，然后还具有传染性，后面的组件还是需要向下层层传递。而且被提升的组件需要和父组件完全解耦，限制也较多。</p>\n<h2 id=\"api\"><a href=\"#api\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API</h2>\n<h3 id=\"reactcreatecontext-、contextprovider\"><a href=\"#reactcreatecontext-%E3%80%81contextprovider\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.createContext 、Context.Provider</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> MyContext <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createContext</span><span class=\"token punctuation\">(</span>defaultValue<span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">&lt;</span>MyContext<span class=\"token punctuation\">.</span>Provider value<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">MyContext.Provider</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效（有点类似解构赋值时，只有在 undefined 下赋值才有用）。</p>\n<p>Provider 接收一个 value 属性，传递给消费组件。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>\n<p>当 Provider 的 value 值发生变化时，它内部的<strong>所有</strong>消费组件都会重新渲染。这是因为更新 value 值一般是使用 setState，所以为引发后代更新。从 Provider 到其后代 consumer 组件的传播，不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。</p>\n<blockquote>\n<blockquote>\n<p>那么在 context 更新时，如何避免重复渲染呢？</p>\n</blockquote>\n</blockquote>\n<h3 id=\"classcontexttype\"><a href=\"#classcontexttype\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class.contextType</h3>\n<p><code class=\"language-text\">static contextType = MyContext</code></p>\n<p>此属性可以让你使用 this.context 来获取最近 Context 上的值，但是只能订阅单一 context，也就是最近的 Provider 提供的。</p>\n<h3 id=\"contextconsumer\"><a href=\"#contextconsumer\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context.Consumer</h3>\n<p>这种方法需要一个函数作为子元素。这个函数接受 context 的值作为参数，并返回一个 React 节点。</p>\n<h3 id=\"使用技巧\"><a href=\"#%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用技巧</h3>\n<ul>\n<li>深层组件更新 context</li>\n<li>同一个组件消费多个 context</li>\n</ul>","timeToRead":2,"frontmatter":{"title":"useContext 的全部","date":"September 02, 2021","spoiler":"一文搞懂 useContext","cta":"react"},"fields":{"slug":"/useContext/","langKey":"en"}}},"pageContext":{"slug":"/useContext/","previous":{"fields":{"slug":"/useRef/","langKey":"en","directoryName":"useRef"},"frontmatter":{"title":"useRef 的全部"}},"next":null,"translations":[],"translatedLinks":[]}},"staticQueryHashes":["708209134"]}